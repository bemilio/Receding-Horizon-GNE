function [C_x, d_x, ...
          C_u_loc, d_u_loc,...
          C_u_sh, d_u_sh,...
          C_u_mix, C_x_mix, d_mix, ...
          x_offs, u_offs] = defineConstraintsAndTarget(N, p, game)
    n_u = 3;
    n_agent_states = 3;
    n_x = n_agent_states*N; % N decoupled systmes
    %% State constraints
    min_x = zeros(n_x, 1);
    max_x = zeros(n_x, 1);
    for i = 1:N
        indexes = (i-1)*n_agent_states+1: i*n_agent_states;
        min_x(indexes,:) = [ 0; % minimum speed of generators 
                             0; % minimum battery charge
                             p.min_cum_load_delay(i)]; ... %load deferral limit
        max_x(indexes,:) = [1; % max generator speed
                            p.max_b_charge(i); % max battery charge
                            p.max_cum_load_delay(i)]; %traslate to reference point
    end
    d_x = [-min_x; max_x]; % affine part of constraints on x 
    C_x = [-eye(n_x); eye(n_x)];

    %% Local input constraints
    for i = 1:N
        min_u(:,:,i) = [p.min_g_rate(i); % minimum acceleration of generators 
                        p.min_b_rate(i); % minimum battery charging rate 
                        p.min_load_delay(i)] ;
        max_u(:,:,i) = [p.max_g_rate(i); % maximum acceleration of generators 
                        p.max_b_rate(i); % maximum battery charging rate 
                        p.max_load_delay(i)] ;
    end
    C_u_loc = zeros(2*n_u, n_u, N);
    d_u_loc = zeros(2*n_u, 1, N);
    for i=1:N
        C_u_loc(:,:,i) = [-eye(n_u); eye(n_u)];
        d_u_loc(:,:,i) = [-min_u(:,:,i); max_u(:,:,i)]; 
    end

    %% Shared input constraints
    % sum_i C_u(:,:,i) * u_i(t) <= d(:,:,i)

    % Dummy constraints
    C_u_sh = zeros(1, n_u, N);
    d_u_sh = zeros(1, 1);

    %% Mixed input-state constraints
    % C_x * x(t) + sum_i C_u(:,:,i) * u_i(t) <= d(:,:,i)
    % In particular:
    % sum_i  load_i(t) + u_bi(t) - v_to_P(i) * v_g(t)   <=  max_L
    % where load_i(t) = u_di(t) + load_ref(i)
    % u_di(t) is the i-th deferral of consumption, load_ref is the nominal load
    % u_bi(t) is the power drawn from the battery
    % v_g(t) is the speed of the generator
 
    max_load_traslated = p.max_cum_load - sum(p.load); 
    min_load_traslated = p.min_cum_load - sum(p.load); 
    C_u_mix = zeros(2,n_u, N);
    C_x_mix = zeros(2,n_x);
    d_mix = 0*[ max_load_traslated;
              -1* min_load_traslated ];

    for i=1:N
        indexes_x = n_agent_states * (i-1) + 1 : n_agent_states * i;
        C_x_mix(:, indexes_x) = 0*[  [-1*p.v_to_P(i), 0, 0];
                                -1*[-1*p.v_to_P(i), 0, 0] ];
        C_u_mix(:,:,i) = 0*[  [0, 1, 1];
                         -1*[0, 1, 1] ];
    end

    %% Define selected equilibrium
    load_setpoint = sum(p.load) - p.collective_load_ref; % Collective power that should be generated by local dispatchable generators
    n_constraints_at_equilibrium = 2*N; % desired state of charge; delay of consumption=0
    Q = zeros(n_x + n_u*N);
    q = zeros(n_x + n_u*N,1);
    C_eq_u = zeros(n_constraints_at_equilibrium,n_u,N);
    % Target selector objective: Approach the collective load reference as close as possible
    % sum_i P_load + P_charge_batt - P_gen = P_reference_grid
    % Write it as [Q_x, Q_u_1 ,... Q_u_N] [x;u] = load_setpoint
    % Put it then the latter constraint in the cost as quadratic penaltu
    Q_x = [];
    Q_u = [];
    for i=1:N
        Q_x = [Q_x, [1*p.v_to_P(i),0,0]];
        Q_u = [Q_u, [0,-1,-1]];
    end
    Q = [Q_x, Q_u]' * [Q_x, Q_u];
    q = -[Q_x, Q_u]' * load_setpoint;
    C_eq_x = [kron(eye(N), [0,1,0]); kron(eye(N), [0,0,1])];
    d_eq_u = [p.q_des; zeros(N,1)];

    [x_offs, u_offs] = targetSelector(game.A, game.B, Q, q, C_eq_x, C_eq_u, d_eq_u, C_x, d_x, C_u_loc, d_u_loc);

    %% Translate constraints NOTE: TO BE DEFINED FOR MIXED AND SHARED CONSTR.
    d_x = d_x - C_x * x_offs;
    for i=1:N
        d_u_loc(:,:,i) = d_u_loc(:,:,i) - C_u_loc(:,:,i) * u_offs(:,:,i);
    end

end

